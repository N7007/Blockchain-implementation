//SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import "@openzeppelin/contracts/utils/Strings.sol";

contract sist_votacion {

    // Estructura para representar una opción de voto
    struct opcion{
        uint256 votoCant;
        string nombre;
    }

    // Lista de opciones de voto
    opcion[] private opciones;

    // Mapping para almacenar los votos de los usuarios
    mapping(address => bool) private yaVotado;

    // Evento para notificar cuando un voto se registra
    event VotoRegistrado(address indexed voter, uint256 indexed opcionIndex);

    // Agregar una opción de voto al sistema
    function agregaropcion(string memory _nombre) public {
        opciones.push(opcion(0, _nombre));
    }

    // Realizar un voto por una opción
    function voto(uint256 _opcionIndex) public {
        require(_opcionIndex < opciones.length, "Opcion de voto invalida");
        require(!yaVotado[msg.sender], "Usted ya ha votado");
        opciones[_opcionIndex].votoCant++;
        yaVotado[msg.sender] = true;
        emit VotoRegistrado(msg.sender, _opcionIndex);
    }

    // Obtener el número total de opciones de voto
    function obtenerOpcionCant() public view returns (uint256) {
        return opciones.length;
    }

    event Resultado(string nombre, uint256 votoCant);
    event PrintMessage(string message);

    function mostrarVotosNombres() public view returns (string memory){
        if (opciones.length > 0){
            string memory resultado = "Los candidatos son: \n";
            for (uint256 i = 0; i < opciones.length; i++) {
                string memory myString = uint256ToString(opciones[i].votoCant);
                resultado = string(abi.encodePacked(resultado, "\n", "Nombre: ", opciones[i].nombre," // cantidad de votos: ", myString, " || "));
            }
            return resultado;
        }else{
            return "No hay ningun candidato";
        }
    }

    // Obtener el recuento de votos para una opción específica
    function obtenerVotosCant(uint256 _opcionIndex) public view returns (string memory) {
        require(_opcionIndex < opciones.length, "Opcion invalida");
        Strings.toString(opciones[_opcionIndex].votoCant);
        string memory myString = uint256ToString(opciones[_opcionIndex].votoCant);
        string memory texto = string(abi.encodePacked("cantidad de votos: ", myString));
        return  texto;
    }

    // Pasar un valor uint256 a string
    function uint256ToString(uint256 value) private pure returns (string memory) {
        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits--;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }
}